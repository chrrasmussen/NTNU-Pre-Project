{"id":"Grensesnitt og oppførsel.txt#content","checksum":"13309e16ef5e28c326f81225b595b871","text":"Interface Most objects have a state, and in explaining the behavior of the object, ie what operations the object makes, so it is natural to refer to how these reads and modifies the condition. Take as an example a counter object with methods void count () and int getCounter (). If the behavior to be explained, it is natural to say that count () increases the counter and that getCounter () returns the counter value, ie a description based on the object&#39;s internal state. The image we give of the object is a combination of state (attributes) and behavior (operations), as shown on the left in the figure below. This dainty in a manner information about the behavior is realized, and violate the principle of encapsulation, which only operations should be publicly disclosed. An encapsulated version of the counter is shown in the middle, and here we arrive at that only operations that are supposed to be known. But that enclosure shall be effective as hiding information about the internal state and the implementation details, want a really only focus on the object&#39;s interface to the outside world, which is the operations and attributes of public visibility (see figure to the right and footnote notation). Attributes and operations Encapsulation of state using. visibility interface, only operations Interface behavior interface of an object thus consists of what is publicly available, and the description of the behavior one wishes to avoid bringing in a possible internal state, since this matter is supposed to be hidden. If we try to do this for Counter, we see that the behavior of the count () and getCounter () is connected, then the description of count () must refer to getCounter (): If getCounter () returns n, then a call to count () do that getCounter () returns the n +1. This is typical of operations that read and modify the same underlying condition, as is the case for getter and setter pair: getX () returns the argument value to the last call to the SETX (...). In practice it is often easiest to describe the behavior of a code example with specific values ​​as shown below. This is particularly useful when one wants to Conduct unit testing and test whether the behavior is correctly implemented. Explicit interface All objects / classes thus has an interface, which is publicly known operations offered other objects / classes and the behavior that these implements. This interface can be useful to make explicit, regardless of whether it is implemented (yet in some specific class). Firstly there is this other classes are interested in and that these must code against. By making explicit interface can using it independent of and perhaps before implementation is ready. Second, the interface works and especially the description of the behavior as a specification for implementation, and it is always good to have ready in advance before starting the implementation. Thirdly, it may be appropriate with multiple implementations with different characteristics and variations within the scope of the prescribed behavior. The figure above shows how the relationship between an (explicit) interface and a class that implements the interface illustrated. To the left is shown how Counter interface is implemented by CounterImpl class. To the right is shown how two different classes can implement the same interface (see footnote notation), and the names indicate that they represent different variants of a parent&#39;s behavior, namely the counting of the number (in the direction of and) to another. Note that in this case it is important that the two classes do not only have the required methods, but implements the behavior according to the requirements. Questions for reflection Try to describe the interface of a stack (eng: stack), with methods push (), peek (), pop () and isEmpty () 1) The symbol stands for the interface, which is the English term, while C &#39;stands for class. One uses a dashed arrow from the class implementing the interface, to distinguish it from the inheritance between interfaces."}