{"id":"Enhetstesting med JUnit.txt#content","checksum":"c636da1f44089413363f5e225b4a5fed","text":"Unit testing is the testing of the smallest units in a program, ie to test the methods in a class implements the desired behavior. JUnit is a practical framework for doing unit testing of Java classes. Put simply consists unit testing with JUnit, also called JUnit testing, to create instances of the class to test and try different sequences of method calls and check if the values ​​they return matches the &quot;gold standard&quot;. Let&#39;s take the following class as an example. is intended to implement a count from an initial value to (but not with) a final value. Every time we call method that will increase the counter by 1, but only if we have not yet reached the final value. As the final value is reached, then return, otherwise. The counter value we get hold of the method. Before we test class, we must formulate the behavior as testable statements (rules) of method calls and return values. A utsagt which the counter will be increased whenever called, does not hold, since the counter is part of the private state of the class and not part of the class method interface. Here are statements only constructor and methods: After the class is instantiated with to return. &#39;ll return one more each time called, unless the value has been. The call to that allows returns, the return, otherwise. Now that the statements of conduct only about calls to open the available methods, it is relatively easy to write code that tests them. We instantiate simply Counter objects and performs sequences of calls and checks the return value against gold standard. JUnit framework has ready-made methods of the past, thus comparing an actual value with an expected value. Let&#39;s look at the test code for the first statement above:-entity who created the first line is supposed to count from 0 to (and including) 2 Second line checks if getCounter () returns the expected values ​​0 Safety checks call to whether the arguments are equal, where the first argument is the gold standard and the second actual (return) value. To check the second statement we need to do a few rounds of calls to and and check the return value against gold standard for every call: How do we then run the code above, so that we have tested whether the code is correct according to the requirements? The code must first be entered in the test methods in a test class, and it must be run using the JUnit framework. A test class must inherit from JUnit&#39;s class and test methods must be void methods with no arguments, whose names start with &quot;test&quot; as follows: In Eclipse, it is now simply right-click on the test class and choose Run as-&gt; JUnit Test. Then all the test methods in the test class to be run and the results are shown in a separate JUnit panel: The message says that our check in line 6 in CounterTest.java has revealed an error, counter.getCounter () returned 0, while the expected values ​​were 1! If we look at the code, we see that we have forgotten to initialize pos variable to the initial value. Therefore it started at 0 instead of 1 If we change line 4 in Counter.java and running again, so the error should be fixed: Where we uncovered another error (the program stops at the first error in each test method), in our check in line 9 we received, but the gold standard was. The problem this time is that the count () method returns true also the last time it increases the counter. We need to change some of the logic, as follows: This time, running the test without error and we have (more) reason to believe that the class is implemented according to the requirements. Some final comments: In this example we have only tested our class with one set of test data and this is rarely enough to find all errors. If we for example. had instantiated with new Counter (0, 2), so did not have the first error detected, since the default value happened to be right! Therefore it is wise to test the probable, improbable and often random values. It is common to structure code in many small test methods, each of which tests only one requirement. In this case, we could have made two test methods, for example. To test the constructor, and test method. When driving, both test methods will be carried out and we can detect more errors at once. Moreover, it will often be convenient to write individual using methods to make the test methods tidier. Read also"}