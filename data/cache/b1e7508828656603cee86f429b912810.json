{"id":"Swing.txt#content","checksum":"1d1e5a16277eddd06797ef3c5c0ebac8","text":"General Swing is a &quot;lightweight&quot; API to create GUI for Java. Swing has an architecture that makes it possible to add graphics to code, without changing too much on the application. The swing can easily create buttons, text fields, check boxes, labels, tables and lists, as well as a number of other components. For more on the components and how they work, see the Swing components. Basic component usage and structure A common way to build a GUI application with swing is to use classes JFrame and JPanel for a specific pattern. The concept is about having a class A, subclass (inherit) JPanel. A filling itself with components (text, buttons, etc.) and form all (or part) of a window. Note that an instance of JPanel, a panel, a component on a par with a text field. An instance of A, a, is thus a component designed so you want his window to look out, but a will not create any window that we can see and touch. Here comes the JFrame. An instance of JFrame represented as an actual window on the PC screen. In this window you can add components in the same way as a panel, but to create a structure we fill the entire window or frame with panel A. If you want a button at the bottom of its window, this added words to a panel, not in frame. Explanation to the following structure: It is common to structure code to class corresponding to a window or panel, typically a subclass of JPanel even filling with contents and responding to user interaction with content (explained later). For smaller applications, without the menu bar is unusual to subclass JFrame, because this is less common to reuse. Instead subclass JPanel as instantiated in a main method together with a JFrame and set as JFrame contentPane. The example below shows how to create a panel (JPanel) that fills itself with components. If the application has the main method (JFrame) as shown below, it creates a window which is filled with the panel MySimplePanel. Attention! Adjust the window size when testing code. This is the layout (Border Layout) You can read more about here. Event-driven applications If you make an application that will accept user interaction (button pressing, typing on keyboard, mouse, choice of menus, etc.), this builds on the structure of the structure explained above. We want to keep the interaction on the panel, not in the frame. The principle behind user interaction is based on placing the listeners on components on their panel. This means that when a button, key, etc.. pressed, this perceived by the listener to this component (consider this automagically for now) that tells the panel that something has happened, and what happened. For the listener should be able to advise the panel, it must have a method that listener knows about. The panel must implement Action Listener interface, which means that the panel has guaranteed method void actionPerformed (ActionEvent e). Attention! Run the code and see below for a description of key lines of code NB! Line number in full screen Line 11.8: Creating global components that we need to reach from the whole class. Lines 15-16: After we have created buttons btn1 &amp; 2, we set a listener at the. Without this listener will not send any message that the button has been pressed. The parameter here specifies who should be notified about the incident. Line 24: Creates a component that does not need to be global. Lines 26-31: Creates one &quot;subpanel&quot; and adds two buttons to the East and West on this panel. Then apply the &quot;subpanelet&quot; to the very top of the main panel. Ie, the two buttons will be on top of the main panel, and then right and left. Line 38: The function which listeners call when user interaction is made. The parameter e is an Action object that carries information about the event that occurred. Line 40-42: If the source of the event is btn1 will appear a dialog box with text. Line 43-45: If the source of the event is btn2 be text in the input text be blank."}