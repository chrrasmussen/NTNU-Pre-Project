{"id":"Tall og beregninger.txt#content","checksum":"7ed7e74312aef4938516e30e0a6bb740","text":"General In java, we operate with six primitive numeric types with different characteristics, which are used differently then. There are four integer types and two floating-point types. The difference between these internally is the number of bit number represented by and accuracy of those. The most commonly used types are int and double. It is important to note that the figures they operate in java is not ideal mathematical numbers, but is represented by a limited number of bits, which can lead to undesirable properties. Content Type Default Value Size Range byte Integer 0:08 -128 to 127 short Integer 0:16 32768 to 32767 int Integer 0:32 2,147,483,648 to 2,147,483,647 long Integer 0 64 -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 float Floating point 0.0 32 + / - 1.4E-45 to + / - 3.4028235E +38 double Floating point 0.0 64 + / - 4.9E-324 to + / - 1.7976931348623157E +308 Integer There will rarely be any any reason to use anything other than int when using integers. It would then be if you need really big numbers (see above), which can be resolved with a long. Or they have strict requirements for minnesparsommelighet and to have large amounts of integers in the array without requiring the entire range of the int. In that case, a short, or byte be a possibility. If we want to convert between two integers will be fine if the number is within the range of the new type. i is within the range of bytes in is out of range for byte Do not cast the &quot;upward&quot; Note that the wrapper classes (see below) provides support for conversion between numeric types without casting. Floating What floating point relates to it will seldom be reason to use anything other than double. The important thing to note is that a floating point becomes less and less accurate the more it gets and that one can experience the imprecise estimates even with small values. Remember that we are trying to represent floating point numbers with a limited number of bits, which allows for errors. Precision is the key, and as shown above, this is not always perfect. With this in mind, we must always be cautious when comparing double values. Do not use ==, but rather a very small epsilonverdi to filter out small arithmetic &quot;error&quot;. Double also take three &quot;strange&quot; values ​​that are good to know about: NaN: &quot;Not a number&quot;, NaN can be assigned to a double if we try to perform operations that can not be done. See, Example 1 Infinity, &quot;Infinity,&quot; Infinity is larger than all numbers, and follow some simple rules, such as 2 -Infinity &quot;negative infinity&quot;,-Infinity is less than every number, and follow the same rules as Infinity. Example 1 Example 2 Wrapper classes The primitive numeric types in Java has a &quot;wrapper&quot; class. These classes wraps the primitive numeric type, and makes it possible to represent it as an object. This is often done by the compiler and is then called &quot;auto-boxing&quot;. In java, there is a Number class that subclasses of the various wrapper classes. Number class is abstract with the abstract methods byte value (), short value () ... double value () that subclasses implement to convert to specific numeric types. A number object will always be an instance of one of the subclasses. Photo from Oracle pages. Integer classes have useful methods and attributes and methods MAX_VALUE, MIN_VALUE, toString (), valueof (). In addition implements all figures classes Comparable thus compareTo () method, so that numbers can be sorted. One should not use numbers objects indiscriminately and it&#39;s essentially three cases we take the wrapper classes to numbers in use: when one must mix different numeric types or numbers types and other object types when one wants to use Collection framework together with numbers (both Collection and Map subclasses) when one wishes to distinguish between non-any number (zero) and a valid numeric value Collections of numbers when we want to store the number in a Collection object numbers must be objects, but Java has mechanisms in many cases do this for us. More about why we initialize collections with a class name Value Types and classes in javaher. As noted above, java mechanisms that convert to us if it is quite obvious what values ​​and types as expected"}