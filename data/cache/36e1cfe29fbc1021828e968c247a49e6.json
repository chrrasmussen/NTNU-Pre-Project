{"id":"Testing av unntak.txt#content","checksum":"0a8a310bf41a8591d7e6942d1ba22ba2","text":"Unit testing is the testing of the smallest units in a program, in practice, individual classes and their methods. On testing methods, a typical rig up one or more authority, call methods with different arguments and return values ​​compare with the gold standard. However, this will not test another important aspect of the methods, namely when and which exceptions triggered, for example. when the arguments are invalid. Testing this is not as straight forward as the testing of return values, and therefore one needs to know various techniques to test exceptions. The easiest would be if there was a assertException method in JUnit framework. Such a method is, however, impossible to implement, because the exception provides a special type of control flow, which disrupts the normal control flow used in method calls. Therefore, we must instead create test code adapted to the extraordinary exception control flow. The usual technique for dealing exception is the use of which provides the following control flow: When testing exceptions, you will typically want to check if the control flow continues as normal or ports in a specific catch-part. To specify that a particular control flow is not as expected, ie &quot;hit would not come&quot;, calling one method, which simply gives an error message immediately, almost as if one were using. Suppose for example. the constructor in the Counter class from Unit Testing with JUnit should trigger an IllegalArgumentException if the end value is less than the start value. Remember to test both cases, both when one expects the exception of this kind, and when one does not expect it, often in each test method: A need so far are not catch-branch Exception with fail () in because it will still be captured by the test system, but it is okay to have it because it makes the test code more clearly what kind of exception is expected and not. There is one instance of the code does not cover, namely when it is required an exception of a particular class and a subclass. If the Counter constructor triggers an exception of type NumberFormatException, will be accepted by the test code above, but this exception matches the really. The required constructor should be the exception being the particular class IllegalArgumentException (not a subclass) and this is a test with the following code: It captures an ie up all exceptions and checks the type of the exception instance, returned with e.getClass () , the specific class IllegalArgumentException. Pages on Unit Testing with JUnit:"}