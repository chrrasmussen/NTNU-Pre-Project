<ac:macro ac:name="excerpt"><ac:parameter ac:name="atlassian-macro-output-type">BLOCK</ac:parameter><ac:rich-text-body><p>JavaFX er ment &aring; v&aelig;re Java Swing sin etterf&oslash;lger som Java sitt foretrukne rammeverk for grafikk og brukergrensesnitt fra og med Java 7. JavaFX er bl.a. mer fleksibelt i hvordan man kan kombinere grafikk og interaktive komponenter, har bedre st&oslash;tte for rik grafikk og animasjon, gj&oslash;r det lettere &aring; skille funksjon og det rent visuelle.</p></ac:rich-text-body></ac:macro><p>Som programmerer m&aring; man forholde seg til et fullstendig nytt API (klassene og metodene som utgj&oslash;r rammeverket), men overgangen er ikke s&aring; stor fordi en godt kan bruke kjente teknikker og gradvis ta i bruk de nye mulighetene.</p><h2>Basic oppbygning&nbsp;</h2><p>En JavaFX applikasjon er bygget opp med en&nbsp;<em>stage</em> i bunn som&nbsp;utgj&oslash;r rammen til applikasjonen, og har typisk&nbsp;et navn som vises &oslash;verst applikasjonsvinduet. En&nbsp;<em>stage&nbsp;</em>fylles med en <em>scene. </em>Scenen<em>&nbsp;</em>utgj&oslash;r omr&aring;det hvor vi framstiller knapper, figurer, tekst og andre komponenter.&nbsp;Dette skjer dog ikke helt vilk&aring;rlig, siden alle komponenter m&aring; legges til i&nbsp;en&nbsp;<em>scene graph,&nbsp;</em>og kalles da <em>noder</em> i denne grafen.&nbsp;Grafens struktur bestemmer hvordan nodene rendres p&aring; scenen.</p><p>Alts&aring;:&nbsp;<em>Stage -&gt; Scene -&gt; Scene Graph</em></p><table><tbody><tr><th><p>&nbsp;</p><ac:macro ac:name="code"><ac:parameter ac:name="title">Stage and scene with empty scene graph</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:parameter ac:name="collapse">true</ac:parameter><ac:plain-text-body><![CDATA[import javafx.application.Application;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.paint.Color;
import javafx.stage.Stage;
public class SimpleJavaFX extends Application {
	
	public static void main(String[] args) {
		launch(args);
	}
	@Override
	public void start(Stage stage) throws Exception {
		
		Group root = new Group(); // Root of the scene graph
		
		Scene scene = new Scene(root,500,500, Color.AQUA);
		
		stage.setScene(scene);
		stage.setTitle("Simple JavaFX");
		stage.show();
	}
}]]></ac:plain-text-body></ac:macro><p>&nbsp;</p></th></tr></tbody></table><h2>Scene Graph</h2><p>Det er scenegrafen som styrer selve utformingen av grensesnittet i en JaveFX-applikasjon. <em>JavaFX Scene Graph API</em> gj&oslash;r det mye enklere &aring; lage et GUI ved at en scenegraf p&aring; et hvilket som helst tidspunkt vet hvilke objekter som skal vises frem, hvilke omr&aring;der p&aring; skjermen som m&aring; tegnes p&aring; nytt og hvordan alt skal rendres p&aring; en mest mulig effektiv m&aring;te. Ved &aring; bruke scenegraf API'et&nbsp;slipper man &aring; forholde seg til primitive tegnemetoder og kan heller la systemet ta seg av detaljer omkring rendring.</p><p>En <em>scene graph&nbsp;</em>er en trestruktur som inneholder dataelementer, og hvert element kalles en&nbsp;<em>node</em>. En node er enten en rotnode, intern-node eller l&oslash;vnode, noe som vil si at alle noder i treet, for utenom rotnoden, <strong>m&aring;&nbsp;</strong>ha en parent (forelder). Under er et eksempel p&aring; en enkel <em>scene graph</em>, med elementer b&aring;de som nodetype, og med faktiske klasser som kan tilsvare nodetypen.</p><table><tbody><tr><th><p><ac:image><ri:attachment ri:filename="scene graph_node.png" /></ac:image></p><p>Nodetype<br /><em style="font-size: 10.0pt;line-height: 13.0pt;">- Bildet er hentet fra oracles nettsider</em><span style="font-size: 10.0pt;line-height: 13.0pt;">&nbsp;</span></p></th><th><p><ac:image><ri:attachment ri:filename="scene graph_class.png" /></ac:image></p><p>Klasser som kan opptre som tilsvarende nodetype <br /><em> - Bildet er hentet fra oracles nettsider</em>&nbsp;</p></th></tr></tbody></table><p>M&aring;ten man bygger denne trestrukturen p&aring; er ved &aring; bruke lister med&nbsp;<em>children.&nbsp;</em>Hver node som kan opptre som en intern node har en metode&nbsp;<em>getChildren()&nbsp;</em>som returnerer en liste med n&aelig;rmeste etterkommere. I bildet over vil&nbsp;<em>Groups&nbsp;</em>children-liste inneholde ett&nbsp;<em>circle-,&nbsp;</em>ett&nbsp;<em>rectangle-&nbsp;</em>og ett&nbsp;region-objekt. Videre vil&nbsp;<em>region-</em>objektets liste inneholde&nbsp;ett&nbsp;<em>text-&nbsp;</em>og ett&nbsp;<em>imageview-</em>objekt.<br />Nye barn kan legges til p&aring; to m&aring;ter:</p><ul style="list-style-type: square;"><li><em>parent.getChildren().add(node);&nbsp;</em>Legger til &eacute;n node</li><li><em>parent.getChildren.addAll(node1,node2,node3,....); </em>Legger til flere noder</li></ul><p>I pakken javafx.scene finnes det massevis av klasser, men de tre viktigste for &aring; forst&aring; oppbygningen til <em>Scene Graph API</em> er</p><ul style="list-style-type: square;"><li>Node: Abstrakt baseklasse for alle noder i en scene graph.</li><li>Parent: Abstrakt baseklasse for alle interne noder. (Arver direkte fra Node)</li><li>Scene: Base&nbsp;<em>containeren&nbsp;</em>for alt innholdet i&nbsp;en&nbsp;scene graph.</li></ul><p>Disse klassene inneholder viktig funksjonalitet som arves videre og brukes i forbindelse med tegnerekkef&oslash;lge, synlighet, transformasjoner, osv. <br />Parent arves av diverse internnode-klasser som Control, Group, Region og WebView. Det finnes ogs&aring; utallige l&oslash;vnode-klasser, slik som javafx.scene.shape og&nbsp;javafx.scene.text.</p><h2>Noder</h2><p>Det finnes noen fellestrekk som gjelder for alle nodene man bruker i JavaFX. Alle noder, utenom rotnoden, legges til i grafen ved &aring; <em>addes</em>&nbsp;i listen av barn til en <em>parent</em>-node. En node kan bare eksistere p&aring; et sted. Dersom man fors&oslash;ker &aring; legge til et&nbsp;objekt som <em>child</em> p&aring; flere forskjellige steder i grafen, vil objektet fjernes&nbsp;fra dens forrige <em>parrents</em>&nbsp;liste over&nbsp;<em>children,</em><em>&nbsp;</em>f&oslash;r det <em>addes</em>&nbsp;som&nbsp;<em>child&nbsp;</em>hos sin<em>&nbsp;</em>nye&nbsp;<em>parent</em>. Det kan heller ikke finnes sykler i grafen.&nbsp;</p><p><strong>Id</strong><br />Hver node kan ogs&aring; gis en&nbsp;<em>id.&nbsp;</em>Dette er en id som ligner veldig p&aring; id-tagen i HTML, og det er opp til utvikleren &aring; sikre at en id er unik i en&nbsp;<em>scene graph</em>. En nyttig funksjon i denne forbindelse er&nbsp;<em>lookup(String id)&nbsp;</em>som kan brukes til &aring; finne en node med en unik id i en scene graph. Ellers kan ogs&aring; id'en brukes til &aring; identifisere noder n&aring;r man vil legge til stiler, se mer om&nbsp;<em>css&nbsp;</em>lenger ned.&nbsp;</p><p><strong>Koordinater</strong><br />Nodene f&oslash;lger et tradisjonell grafisk koordinatsystem med &oslash;kende verdier mot h&oslash;yre p&aring; x-aksen, og &oslash;kende verdier nedover p&aring; y-aksen. Med dette er alts&aring; (0,0) lokalisert &oslash;verst til venstre. Man kan ogs&aring; definere koordinatene med flyttall og (0.5 , 0.5) tilsvarer da sentrum av pixelet &oslash;verst til venstre.</p><p><strong>Transformasjoner</strong></p><ul style="list-style-type: square;"><li>Translate flytter i x- og/eller y-retning ut fra nodens referansepunkt. Alts&aring; en enkel forflytning av objektet. TranslateTransition er en utvidelse av Translate og kan gj&oslash;re utf&oslash;re forflytningen som en animasjon.</li><li>Rotation roterer noden et antall grader rundt et gitt referansepunkt. RotateTransition muliggj&oslash;r rotasjonene som en animasjon.</li><li>Scale skalerer noden utfra nodens referansepunkt med en x- og y-faktor. Dersom referansepunktet er &oslash;verst til venstre i noden vil skaleringen utf&oslash;res nedover og mor h&oslash;yre. Klassen ScaleTransition finnes ogs&aring;.</li><li>Shearing roterer en akse slik at x- og y-aksen ikke lenger er vinkelrette for den gjeldende noden</li></ul><p>Etter man har laget en transformasjon tiltenkt en eller flere noder kan man enkelt utf&oslash;re den ved &aring; legge den til i listen(e)&nbsp;av transformasjoner for&nbsp;noden(e):&nbsp;node.getTransforms().add(transform);<br /><br /><strong>Cascading Style Sheets (CSS)</strong></p><p><span style="font-size: 10.0pt;line-height: 13.0pt;">En node har feltene <em>id, styleClass&nbsp;</em>og <em>style.&nbsp;</em>Disse brukes til &aring;&nbsp;endre nodens stil med CSS.&nbsp;Feltene&nbsp;<em>id&nbsp;</em>og&nbsp;<em>styleClass&nbsp;</em>brukes i CSS for &aring; avgj&oslash;re hvilke noder som skal ha de forskjellige stilene.&nbsp;Feltet&nbsp;<em>style&nbsp;</em>brukes til &aring; legge p&aring; en CSS stil til en node direkte i koden. For en basic forst&aring;else av dette konseptet, ta en titt p&aring; denne&nbsp;<a href="http://www.youtube.com/watch?v=tyeqqz7o2pI">videoen</a>. Oracle har ogs&aring; en god&nbsp;<a href="http://docs.oracle.com/javafx/2/css_tutorial/jfxpub-css_tutorial.htm">tutorial</a> for &aring; f&aring; et lite innblikk i mulighetene CSS gir oss.</span></p><p><span style="font-size: 16.0pt;font-weight: bold;line-height: normal;">Layouts</span></p><p>JavaFX har st&oslash;tte for mange forskjellige layouts og stiler gjennom en rekke&nbsp;<em>container-</em>klasser. Disse klassene er p&aring; en m&aring;te forh&aring;ndsdefinerte &quot;beholdere&quot;, og en analogi kan v&aelig;re m&aring;ten et klesskap er utformet. Kl&aelig;rne dine kan legges i store og sm&aring; hyller (gjerne flere plagg i samme hylle), eller henges opp i kleshengere. Dersom det ikke er en hylle der du vil legge fra deg genseren, nei da g&aring;r det ikke &aring; legge genseren der.&nbsp;<br />Her utgj&oslash;r kl&aelig;rne dine noder, mens hyllene og oppheng utgj&oslash;r layout. Det kan godt tenkes at klesskapet i utgangspunktet bare er delt i to, men at det er puttet flere hyller (layouts) i den ene av disse to&nbsp;<em>containerne.</em></p><p>....</p><ac:macro ac:name="metadata-list"><ac:parameter ac:name="orientation">horizontal</ac:parameter><ac:plain-text-body><![CDATA[|| Sidetype | teori |
|| Dekningsgrad | 50 |
|| Omfang | 50 |
|| Ferdig | 50 | ]]></ac:plain-text-body></ac:macro>