<ac:macro ac:name="metadata-list"><ac:parameter ac:name="orientation">horizontal</ac:parameter><ac:plain-text-body><![CDATA[|| Sidetype | teori |
|| Dekningsgrad | 100 |
|| Omfang | 50 |
|| Ferdig | 95 |]]></ac:plain-text-body></ac:macro><p>I java finnes det et sett med primitive datatyper, slik som boolean, char, int, osv. Disse datatypene er forh&aring;ndsdefinerte av spr&aring;ket, og har navn etter sitt eget reserverte&nbsp;<em>keyword</em>.&nbsp;De primitive datatypene deler ikke tilstand med noen av de andre. Mer om de primitive datatypene i java&nbsp;<a href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">her</a>, og for mer om bruken av datatyper generelt&nbsp;<ac:link><ri:page ri:content-title="Datatyper" /><ac:plain-text-link-body><![CDATA[her]]></ac:plain-text-link-body></ac:link>.&nbsp;</p><p>Selv om noen datatyper regnes som primitive i java, kan disse datatypene fortsatt representeres&nbsp;ved en verdiklasse. Det vil si at f.eks.&nbsp;<em>char-</em>datatypen kan &quot;pakkes inn&quot; i en <em>Character-</em>klasse:</p><table><tbody><tr><th><p>&nbsp;</p><ac:macro ac:name="code"><ac:parameter ac:name="title">Character</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[char c_prim = 'c';
Character c_class = new Character('c');
 
System.out.println(c_prim == c_class); // true]]></ac:plain-text-body></ac:macro><p>Her kan man se at java ikke skiller mellom variabler som er initialisert<br />gjennom den primitive datatypen, eller dens tilh&oslash;rende klasse siden disse<br />uttrykker eksakt samme mening. Men ...</p></th><th colspan="1"><p>&nbsp;</p><ac:macro ac:name="code"><ac:parameter ac:name="title">Integer</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[Integer first = new Integer(5);
Integer second = new Integer(5);
 
System.out.println(first == second); // false]]></ac:plain-text-body></ac:macro><p>... de er ikke samme objekter!<br /><br /></p></th></tr></tbody></table><p>Vi kan alts&aring; bruke verdiklasser til &aring; skille mellom objekter, som egentlig uttrykker samme <em>mening.</em>&nbsp;Dette gjelder ogs&aring; for egendefinerte klasser og klasser som finnes i java-biblioteker.<br /><br />I tillegg har de forskjellige verdiklassene ofte et sett med statiske metoder som ofte brukes til &aring; tolke eller modifisere data. String- og Characterklassen har mange slike metoder.<br /><span style="font-size: 10.0pt;line-height: 13.0pt;">Typiske eksempler:</span></p><table><tbody><tr><th>Character</th><th>Integer</th><th>Double</th></tr><tr><td>Character.toLowerCase(char)</td><td>Integer.parseInt(String)</td><td>Double.isInfinite(double)</td></tr><tr><td>Character.isWhitespace(char)</td><td>Integer.doubleValue(int)</td><td>Double.parseDouble(string)</td></tr><tr><td>Character.isDigit(char)</td><td>Integer.toString(int)</td><td>Double.compareTo(double)</td></tr></tbody></table><p>Det er ogs&aring; verdt &aring; merke seg at Number-klassene (Integer,Double,Float,osv) har metoder knyttet til konvertering mellom hverandre som brukes p&aring; objekter, og ikke i statisk sammenheng.&nbsp;</p><p><span style="font-size: 16.0pt;font-weight: bold;line-height: normal;">Verdiklasser knyttet til&nbsp;</span><em style="font-size: 16.0pt;font-weight: bold;line-height: normal;">generics</em></p><p>I tilknytning til&nbsp;<ac:link><ri:page ri:content-title="Collection-rammeverket" /></ac:link>&nbsp;og&nbsp;<em>generic</em><em>s&nbsp;</em>tar vi ogs&aring; i bruk verdiklassene. N&aring;r vi deklarerer en ny collection er det ofte &oslash;nskelig &aring; definere hva slags informasjon som skal legges i denne, og vi vil da m&aring;tte oppgi hvilken <em>verdiklasse</em> informasjonen tilh&oslash;rer. Dette gj&oslash;res ved &aring; legge til verdiklassen(e) som parameter(e) n&aring;r en klasse eller et grensesnitt initialiseres. Dette gj&oslash;res ved &aring; bruke &quot;vinklede brackets&quot; (&lt;&gt;), se eksempel under:</p><table><tbody><tr><th><p>&nbsp;</p><ac:macro ac:name="code"><ac:parameter ac:name="title">Without generics </ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[List list = new ArrayList();
list.add(1337);
int i = (Integer) list.get(0);]]></ac:plain-text-body></ac:macro><p>&nbsp;</p></th><th><p>&nbsp;</p><ac:macro ac:name="code"><ac:parameter ac:name="title">With generics</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[List<Integer> list = new ArrayList<Integer>();
list.add(1337);
int i = list.get(0); // no cast]]></ac:plain-text-body></ac:macro><p>Vi bruker her Integer siden denne klassen &quot;representerer&quot; et int</p></th><th colspan="1"><p>&nbsp;</p><ac:macro ac:name="code"><ac:parameter ac:name="title">With generics</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[List<Person> list = new ArrayList<Person>();
list.add(new Person("Per"));  // Assumes Person-class exists
Person p = list.get(0); // no cast ]]></ac:plain-text-body></ac:macro><p>&nbsp;</p></th></tr></tbody></table><p>Hovedargumentet for &aring; bruke generics er at vi f&aring;r kode som er mer&nbsp;<em>typesikkert</em> ved kompilering (mye lettere &aring; finne bugs ved kompilering enn runtime). I tillegg unng&aring;r vi&nbsp;<em>casting</em> og det muliggj&oslash;r implementering av algoritmer som fungerer p&aring; ulike datatyper. Mer om generics&nbsp;<a href="http://docs.oracle.com/javase/tutorial/java/generics/index.html">her</a>.</p><h2><em>Null-</em>verdi</h2><p>En spesiell verdi i java er&nbsp;<em>null.&nbsp;</em>Denne verdien kan ordnes til alle datatyper og representerer &quot;ingen ting&quot;.&nbsp;<br />Dersom man setter en verdi til null vil det typisk v&aelig;re fordi man &oslash;nsker &aring; uttrykke en av f&oslash;lgende</p><ul style="margin-left: 30.0px;"><li>Uinitialisert tilstand</li><li>Betingelse for terminering</li><li>Ikke-eksisternede objekt</li><li>En ukjent verdi</li></ul><p>En kan ogs&aring; returnere&nbsp;<em>null</em>&nbsp;fra et funksjonskall dersom man vil uttrykke at det ikke er funnet noe, at ingen passer eller at resultatet er ukjent.<br /><br />Noen har sterke meninger knyttet til hvorvidt bruken av null l&oslash;ser mer problemer enn den skaper. I dette kurset er det viktigste &aring; v&aelig;re obs p&aring;&nbsp;<em>NullPointerException</em>&nbsp;som kastes dersom man pr&oslash;ver &aring; kalle metoder eller hente felt fra null. Dersom man f.eks. forventer en String returnert, men f&aring;r null, vil dette skape problemer med mindre man tester om objektet er lik/ulik null: obj ==&nbsp;<em>null &nbsp;/</em>&nbsp; obj !=&nbsp;<em>null</em>).&nbsp;</p><p><br />&nbsp;</p>