<ac:macro ac:name="metadata-list"><ac:parameter ac:name="orientation">horizontal</ac:parameter><ac:plain-text-body><![CDATA[|| Sidetype | teori |
|| Dekningsgrad | 75 |
|| Omfang | 75 |
|| Ferdig | 75 |]]></ac:plain-text-body></ac:macro><h2>Generelt</h2><p>I java opererer vi med seks primitive talltyper med forskjellige egenskaper, som brukes forskjellig deretter. Det er 4 heltalls-typer og 2 flyttalls-typer. Forskjellen p&aring; disse innad er antall bit tallet representeres ved, og n&oslash;yaktighet av de. De mest brukte typene er&nbsp;<em>int&nbsp;</em>og&nbsp;<em>double</em>. Det er viktig &aring; merke seg at tallene man opererer med i java ikke er ideelle matematiske tall, men er representert med et&nbsp;<em>begrenset&nbsp;</em>antall bit, noe som kan f&oslash;re med seg u&oslash;nskede egenskaper.</p><table><tbody><tr><th>Type</th><th>Innhold</th><th>Default-verdi</th><th>St&oslash;rrelse</th><th>Verdiomr&aring;de</th></tr><tr><td>byte</td><td>Heltall</td><td>0</td><td>8</td><td>-128 til 127</td></tr><tr><td>short</td><td>Heltall</td><td>0</td><td>16</td><td>-32,768 til 32,767</td></tr><tr><td>int</td><td>Heltall</td><td>0</td><td>32</td><td>-2,147,483,648 til 2,147,483,647</td></tr><tr><td>long</td><td>Heltall</td><td>0</td><td>64</td><td>-9,223,372,036,854,775,808 til 9,223,372,036,854,775,807</td></tr><tr><td>float</td><td>Flyttall</td><td>0.0</td><td>32</td><td>+/- 1.4E-45 til +/- 3.4028235E+38</td></tr><tr><td>double</td><td>Flyttall</td><td>0.0</td><td>64</td><td>+/- 4.9E-324 til +/- 1.7976931348623157E+308</td></tr></tbody></table><h3>Heltall</h3><p>Det vil sjeldent v&aelig;re noen noe grunn til &aring; bruke noe annet enn <em>int&nbsp;</em>n&aring;r man bruker heltall.&nbsp;Det vil i s&aring; fall v&aelig;re dersom man har bruk for virkelig store tall (se over), som kan l&oslash;ses med et <em>long</em>. Eller man har strenge krav til minnesparsommelighet og skal ha store mengder heltall i <em>array</em> uten &aring; trenge hele verdiomr&aring;det til&nbsp;<em>int. </em>I s&aring; fall vil et&nbsp;<em>short,</em> eller&nbsp;<em>byte</em> v&aelig;re en mulighet.<br />Dersom vi vil konvertere mellom to heltall vil dette g&aring; fint dersom tallet er innenfor verdiomr&aring;det til den nye typen.&nbsp;</p><table><tbody><tr><th colspan="1"><p>&nbsp;</p><ac:macro ac:name="code"><ac:parameter ac:name="title">Correct casting</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[int i = 99;
byte b = (byte) i;
 
System.out.println(b);
 
// 99]]></ac:plain-text-body></ac:macro><p>i er <em>innenfor</em> verdiomr&aring;det til byte</p></th><th colspan="1"><p>&nbsp;</p><ac:macro ac:name="code"><ac:parameter ac:name="title">Incorrect casting</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[int i = 500;
byte b = (byte) i;
 
System.out.println(b);

// -12  ]]></ac:plain-text-body></ac:macro><p><span>i er </span><em>utenfor </em><span>verdiomr&aring;det til</span><em> </em><span>byte</span></p><p>&nbsp;</p></th><th colspan="1"><p>&nbsp;</p><ac:macro ac:name="code"><ac:parameter ac:name="title">Higher #bits</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[int i = Integer.MAX_VALUE;
long l = i;	

System.out.println(l);
 
// 2147483647]]></ac:plain-text-body></ac:macro><p>Trenger ikke caste &quot;oppover&quot;</p></th></tr></tbody></table><p>Merk at&nbsp;<em>Wrapperklassene</em> (se lenger ned) gir st&oslash;tte for konvertering mellom talltypene uten&nbsp;<em>casting</em>.&nbsp;</p><h3>Flyttall</h3><p>Hva flyttall ang&aring;r vil det vil sjeldent v&aelig;re grunn til &aring; bruke noe annet enn <em>double</em>. Det som&nbsp;er viktig &aring; bemerke seg er at et flyttall blir mindre og mindre n&oslash;yaktig desto st&oslash;rre det blir og at man kan oppleve upresise beregninger selv med sm&aring; verdier.&nbsp;</p><table><tbody><tr><th><p>&nbsp;</p><ac:macro ac:name="code"><ac:parameter ac:name="title">Loss of precision</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[double d1 = 0.1;
System.out.println(d1); // 0.1

double d2 = 0.2;
System.out.println(d2); // 0.2
			
System.out.println(d1 + d2); // 0.30000000000000004 

// ??? ]]></ac:plain-text-body></ac:macro><p><br />Husk at vi pr&oslash;ver &aring; representere flyttall med et <em>begrenset</em> antall bit, noe som<br />gir mulighet for feil. Presisjon er n&oslash;kkelordet, og som vist ovenfor er ikke denne <br />alltid helt perfekt.&nbsp;</p></th><th colspan="1"><p>&nbsp;</p><ac:macro ac:name="code"><ac:parameter ac:name="title">Comparing double</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[double d1 = 0.1;
double d2 = 0.2;
double d3 = d1 + d2;
System.out.println( d3 == 0.3); // False]]></ac:plain-text-body></ac:macro><p>Med dette i bakhodet m&aring; vi alltid v&aelig;re varsomme n&aring;r vi sammenligner&nbsp;<br />doubleverdier. Ikke bruk ==, men heller en veldig liten epsilonverdi til &aring; <br />filtrere bort sm&aring; aritmetiske &quot;feil&quot;.</p><ac:macro ac:name="code"><ac:parameter ac:name="title">Epsilonvalue</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[double eps = 0.00001;
 
System.out.println( (d3 - eps < 0.3) && (0.3 < d3 + eps)); // True
 ]]></ac:plain-text-body></ac:macro><p>&nbsp;</p></th></tr></tbody></table><p><em style="font-size: 10.0pt;line-height: 13.0pt;">Double </em><span style="font-size: 10.0pt;line-height: 13.0pt;">tar ogs&aring; tre &quot;merkelige&quot; verdier som er greit &aring; vite om:</span></p><p><span style="font-size: 10.0pt;line-height: 13.0pt;"><strong>NaN: &quot;</strong>Not a number&quot;, NaN kan tildeles en double dersom vi pr&oslash;ver &aring; utf&oslash;re operasjoner som ikke lar seg gj&oslash;re. Se under, eksempel 1.<br /></span><strong style="font-size: 10.0pt;line-height: 13.0pt;">Infinity:</strong><span style="font-size: 10.0pt;line-height: 13.0pt;"> &quot;Uendelig&quot;, Infinity er st&oslash;rre enn alle tall, og f&oslash;lger noen enkle regler, eksempel 2.<br /></span><strong style="font-size: 10.0pt;line-height: 13.0pt;">-Infinity:&nbsp;</strong><span style="font-size: 10.0pt;line-height: 13.0pt;">&quot;Negativ uendelig&quot;, -Infinity er mindre en alle tall, og f&oslash;lger de samme reglene som </span><em style="font-size: 10.0pt;line-height: 13.0pt;">I</em><em style="font-size: 10.0pt;line-height: 13.0pt;">nfinity.</em></p><table><tbody><tr><th><p>Eksempel 1</p><ac:macro ac:name="code"><ac:parameter ac:name="title">NaN-code</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[double d1 = Math.sqrt(-1); // NaN
 
double inf = Double.POSITIVE_INFINITY;
 
double d2 = inf - inf; // NaN]]></ac:plain-text-body></ac:macro><p>&nbsp;</p></th><th><p>Eksempel 2</p><ac:macro ac:name="code"><ac:parameter ac:name="title">Infinity</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[double pos_inf = Double.POSITIVE_INFINITY; // Infinity
double neg_inf = Double.NEGATIVE_INFINITY; // -Infinity
 
System.out.println(pos_inf - 10); // Infinity
System.out.println(neg_inf - 10); // -Infinity
System.out.println(pos_inf * -1); // -Infinity]]></ac:plain-text-body></ac:macro><p>&nbsp;</p></th></tr></tbody></table><p><span style="font-size: 16.0pt;font-weight: bold;line-height: normal;">Wrapper-klassene</span></p><p>De primitive talltypene i java har alle en &quot;wrapper&quot;-klasse. Disse klassene pakker inn den primitive talltypen, og gj&oslash;r det mulig &aring; representere den som et objekt. Dette gj&oslash;res ofte av kompilatoren&nbsp;og kalles da &quot;autoboxing&quot;.<br /><span>I java finnes det en Number-klasse som subklasses av de forskjellige</span><em>&nbsp;wrapper</em><span>-klassene. Number-klassen er abstrakt med de abstrakte metodene <em>byteValue(), shortValue() ... doubleValue() </em>som subklassene implementerer for &aring; kunne konvertere til spesifikke talltyper. Et number-objekt vil alltid v&aelig;re en instans av en av subklassene.</span></p><p><ac:image><ri:attachment ri:filename="objects-numberHierarchy.gif" /></ac:image>&nbsp;<br /><em>Bildet er hentet fra Oracles sider.</em>&nbsp;<br /><br />Heltalls-klassene har nyttige metoder og attributter og metoder som&nbsp;<em>MAX_VALUE, MIN_VALUE,&nbsp;<em>toString(), valueOf().</em></em>&nbsp;<br />I tillegg implementerer alle tallklassene&nbsp;<em>Comparable&nbsp;</em>og dermed metoden&nbsp;<em>compareTo(),&nbsp;</em>slik at tall kan sorteres.&nbsp;</p><p><span style="font-size: 10.0pt;line-height: 13.0pt;">Man skal ikke bruke tallobjekter ukritisk og det er hovedsaklig tre tilfeller vi tar wrapperklassene til tall i bruk:</span></p><ul style="list-style-type: square;"><li>n&aring;r en m&aring; blande ulike talltyper eller talltyper og andre objekt-typer</li><li>n&aring;r en &oslash;nsker &aring; bruke Collection-rammeverket sammen med tall (b&aring;de&nbsp;<span style="font-size: 10.0pt;line-height: 13.0pt;">Collection- og Map-subklasser)</span></li><li>n&aring;r en &oslash;nsker &aring; skille mellom ikke-noe-tall (null) og en gyldig tall-verdi</li></ul><h3>Collections med tall</h3><p>N&aring;r vi &oslash;nsker &aring; lagre tall i et Collection-objekt m&aring; tallene v&aelig;re objekter, men java har mekanismer som i mange tilfeller gj&oslash;r dette for oss.<br />Mer om hvorfor vi initialiserer collections med et klassenavn <ac:link><ri:page ri:content-title="Verdityper og -klasser i java" /><ac:plain-text-link-body><![CDATA[her]]></ac:plain-text-link-body></ac:link>.</p><table><tbody><tr><th><p>&nbsp;</p><ac:macro ac:name="code"><ac:parameter ac:name="title">Adding objekt</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[List<Integer> list = ArrayList<Integer>();


list.add(Integer.valueOf(13)); // valueOf() refererer til et objekt


list.get(0) // En Integer]]></ac:plain-text-body></ac:macro><p>&nbsp;</p></th><th><p>Som nevnt over har java mekanismer som konverterer for oss<br />dersom det er helt tydelig hvilke verdier og typer som forventes</p><ac:macro ac:name="code"><ac:parameter ac:name="title">Auto-converting</ac:parameter><ac:parameter ac:name="language">java</ac:parameter><ac:plain-text-body><![CDATA[list.add(n) // oversettes til
list.add(Integer.valueOf(n)) // og

list.get(i) // oversettes til 
list.get(i).intValue() ]]></ac:plain-text-body></ac:macro><p>&nbsp;</p></th></tr></tbody></table>